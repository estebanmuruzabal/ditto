{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport { isClient } from './use-is-client';\nexport let ScrollDirections;\n\n(function (ScrollDirections) {\n  ScrollDirections[ScrollDirections[\"Horizontal\"] = 0] = \"Horizontal\";\n  ScrollDirections[ScrollDirections[\"Vertical\"] = 1] = \"Vertical\";\n})(ScrollDirections || (ScrollDirections = {}));\n\nfunction scrollToPercent(el, {\n  container,\n  percentOfElement,\n  offsetPX,\n  direction,\n  percentOfContainer\n}) {\n  const rect = el.current.getClientRects()[0];\n  const isVertical = direction === ScrollDirections.Vertical;\n  const refSize = isVertical ? rect.height : rect.width;\n  const elemScroll = isVertical ? rect.y : rect.x;\n  const scrollSize = container === window ? isVertical ? container.innerHeight : container.innerWidth : isVertical ? container.scrollHeight : container.scrollWidth;\n  let addOffset = refSize * percentOfElement / 100;\n\n  if (offsetPX) {\n    addOffset += offsetPX;\n  }\n\n  const containerScroll = isVertical ? container.scrollY : container.scrollX;\n  const newScroll = containerScroll + elemScroll + (scrollSize * percentOfContainer / 100 + addOffset);\n  const scrollObj = isVertical ? {\n    top: newScroll\n  } : {\n    left: newScroll\n  };\n  window.scrollTo(_objectSpread(_objectSpread({}, scrollObj), {}, {\n    behavior: 'smooth'\n  }));\n}\n\nexport function useRefScroll({\n  percentOfElement = 50,\n  offsetPX = 0,\n  onMount = false,\n  container = isClient ? window : null,\n  percentOfContainer = 50,\n  direction = ScrollDirections.Vertical\n}) {\n  const elRef = useRef(null);\n  const scroll = useCallback(() => {\n    if (elRef.current) {\n      scrollToPercent(elRef, {\n        percentOfElement,\n        offsetPX,\n        container,\n        percentOfContainer,\n        direction\n      });\n    }\n  }, [elRef.current]);\n  useEffect(() => {\n    if (onMount) {\n      scroll();\n    }\n  }, []);\n  return {\n    elRef,\n    scroll\n  };\n} // function MyComponent() {\n//   // using the hook without arguments will scroll the element to the center of the\n//   // window's viewport\n//   // alias elRef to myDiv for easier usage if having multiple elements\n//   // in the same component\n//   const { elRef: myDiv, scroll } = useRefScroller();\n//   return (\n//     <div>\n//       <button onClick={scroll}>Scroll</button>\n//       <div ref={myDiv}>\n//         `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum efficitur, massa vitae consectetur egestas, justo magna\n//         facilisis arcu, non accumsan lacus ipsum sit amet nisl.`\n//       </div>\n//     </div>\n//   );\n// }","map":{"version":3,"sources":["/Users/estebanmuruzabal/work/ditto/client/packages/shop/src/utils/use-ref-scroll.ts"],"names":["useRef","useCallback","useEffect","isClient","ScrollDirections","scrollToPercent","el","container","percentOfElement","offsetPX","direction","percentOfContainer","rect","current","getClientRects","isVertical","Vertical","refSize","height","width","elemScroll","y","x","scrollSize","window","innerHeight","innerWidth","scrollHeight","scrollWidth","addOffset","containerScroll","scrollY","scrollX","newScroll","scrollObj","top","left","scrollTo","behavior","useRefScroll","onMount","elRef","scroll"],"mappings":";;;;;;AAAA,SAASA,MAAT,EAAiBC,WAAjB,EAA8BC,SAA9B,QAA+C,OAA/C;AACA,SAASC,QAAT,QAAyB,iBAAzB;AACA,WAAYC,gBAAZ;;WAAYA,gB;AAAAA,EAAAA,gB,CAAAA,gB;AAAAA,EAAAA,gB,CAAAA,gB;GAAAA,gB,KAAAA,gB;;AAKZ,SAASC,eAAT,CACEC,EADF,EAEE;AACEC,EAAAA,SADF;AAEEC,EAAAA,gBAFF;AAGEC,EAAAA,QAHF;AAIEC,EAAAA,SAJF;AAKEC,EAAAA;AALF,CAFF,EASE;AACA,QAAMC,IAAI,GAAGN,EAAE,CAACO,OAAH,CAAWC,cAAX,GAA4B,CAA5B,CAAb;AACA,QAAMC,UAAU,GAAGL,SAAS,KAAKN,gBAAgB,CAACY,QAAlD;AACA,QAAMC,OAAO,GAAGF,UAAU,GAAGH,IAAI,CAACM,MAAR,GAAiBN,IAAI,CAACO,KAAhD;AACA,QAAMC,UAAU,GAAGL,UAAU,GAAGH,IAAI,CAACS,CAAR,GAAYT,IAAI,CAACU,CAA9C;AAEA,QAAMC,UAAU,GACdhB,SAAS,KAAKiB,MAAd,GACIT,UAAU,GACRR,SAAS,CAACkB,WADF,GAERlB,SAAS,CAACmB,UAHhB,GAIIX,UAAU,GACVR,SAAS,CAACoB,YADA,GAEVpB,SAAS,CAACqB,WAPhB;AASA,MAAIC,SAAS,GAAIZ,OAAO,GAAGT,gBAAX,GAA+B,GAA/C;;AACA,MAAIC,QAAJ,EAAc;AACZoB,IAAAA,SAAS,IAAIpB,QAAb;AACD;;AAED,QAAMqB,eAAe,GAAGf,UAAU,GAAGR,SAAS,CAACwB,OAAb,GAAuBxB,SAAS,CAACyB,OAAnE;AACA,QAAMC,SAAS,GACbH,eAAe,GACfV,UADA,IAEEG,UAAU,GAAGZ,kBAAd,GAAoC,GAApC,GAA0CkB,SAF3C,CADF;AAKA,QAAMK,SAAS,GAAGnB,UAAU,GAAG;AAAEoB,IAAAA,GAAG,EAAEF;AAAP,GAAH,GAAwB;AAAEG,IAAAA,IAAI,EAAEH;AAAR,GAApD;AAEAT,EAAAA,MAAM,CAACa,QAAP,iCACKH,SADL;AAEEI,IAAAA,QAAQ,EAAE;AAFZ;AAID;;AAyBD,OAAO,SAASC,YAAT,CAAsB;AAC3B/B,EAAAA,gBAAgB,GAAG,EADQ;AAE3BC,EAAAA,QAAQ,GAAG,CAFgB;AAG3B+B,EAAAA,OAAO,GAAG,KAHiB;AAI3BjC,EAAAA,SAAS,GAAGJ,QAAQ,GAAGqB,MAAH,GAAY,IAJL;AAK3Bb,EAAAA,kBAAkB,GAAG,EALM;AAM3BD,EAAAA,SAAS,GAAGN,gBAAgB,CAACY;AANF,CAAtB,EAOQ;AACb,QAAMyB,KAAK,GAAGzC,MAAM,CAAC,IAAD,CAApB;AAEA,QAAM0C,MAAM,GAAGzC,WAAW,CAAC,MAAM;AAC/B,QAAIwC,KAAK,CAAC5B,OAAV,EAAmB;AACjBR,MAAAA,eAAe,CAACoC,KAAD,EAAQ;AACrBjC,QAAAA,gBADqB;AAErBC,QAAAA,QAFqB;AAGrBF,QAAAA,SAHqB;AAIrBI,QAAAA,kBAJqB;AAKrBD,QAAAA;AALqB,OAAR,CAAf;AAOD;AACF,GAVyB,EAUvB,CAAC+B,KAAK,CAAC5B,OAAP,CAVuB,CAA1B;AAYAX,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIsC,OAAJ,EAAa;AACXE,MAAAA,MAAM;AACP;AACF,GAJQ,EAIN,EAJM,CAAT;AAMA,SAAO;AAAED,IAAAA,KAAF;AAASC,IAAAA;AAAT,GAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\nimport { isClient } from './use-is-client';\nexport enum ScrollDirections {\n  Horizontal,\n  Vertical\n}\n\nfunction scrollToPercent(\n  el,\n  {\n    container,\n    percentOfElement,\n    offsetPX,\n    direction,\n    percentOfContainer\n  }: ScrollOpts\n) {\n  const rect = el.current.getClientRects()[0];\n  const isVertical = direction === ScrollDirections.Vertical;\n  const refSize = isVertical ? rect.height : rect.width;\n  const elemScroll = isVertical ? rect.y : rect.x;\n\n  const scrollSize =\n    container === window\n      ? isVertical\n        ? container.innerHeight\n        : container.innerWidth\n      : isVertical\n      ? container.scrollHeight\n      : container.scrollWidth;\n\n  let addOffset = (refSize * percentOfElement) / 100;\n  if (offsetPX) {\n    addOffset += offsetPX;\n  }\n\n  const containerScroll = isVertical ? container.scrollY : container.scrollX;\n  const newScroll =\n    containerScroll +\n    elemScroll +\n    ((scrollSize * percentOfContainer) / 100 + addOffset);\n\n  const scrollObj = isVertical ? { top: newScroll } : { left: newScroll };\n\n  window.scrollTo({\n    ...scrollObj,\n    behavior: 'smooth'\n  });\n}\n\ninterface ScrollOpts {\n  /**\n   * Offset in percentage of the element's client dimentions\n   * default is to scroll to center the element in the scrolling pane, hence 50%\n   */\n  percentOfElement?: number;\n  /**\n   * The offset in pixels, whch will be added to the percentage of the element\n   */\n  offsetPX?: number;\n  /**\n   * Whether to run the scroll on mounting\n   */\n  onMount?: boolean;\n  /**\n   * The scrollable container in which the ref element is scrolling\n   */\n  container?: any;\n  // default is the center of the scrolling container, hence 50%\n  percentOfContainer?: number;\n  direction?: ScrollDirections;\n}\n\nexport function useRefScroll({\n  percentOfElement = 50,\n  offsetPX = 0,\n  onMount = false,\n  container = isClient ? window : null,\n  percentOfContainer = 50,\n  direction = ScrollDirections.Vertical\n}: ScrollOpts) {\n  const elRef = useRef(null);\n\n  const scroll = useCallback(() => {\n    if (elRef.current) {\n      scrollToPercent(elRef, {\n        percentOfElement,\n        offsetPX,\n        container,\n        percentOfContainer,\n        direction\n      });\n    }\n  }, [elRef.current]);\n\n  useEffect(() => {\n    if (onMount) {\n      scroll();\n    }\n  }, []);\n\n  return { elRef, scroll };\n}\n\n// function MyComponent() {\n//   // using the hook without arguments will scroll the element to the center of the\n//   // window's viewport\n//   // alias elRef to myDiv for easier usage if having multiple elements\n//   // in the same component\n\n//   const { elRef: myDiv, scroll } = useRefScroller();\n\n//   return (\n//     <div>\n//       <button onClick={scroll}>Scroll</button>\n\n//       <div ref={myDiv}>\n//         `Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum efficitur, massa vitae consectetur egestas, justo magna\n//         facilisis arcu, non accumsan lacus ipsum sit amet nisl.`\n//       </div>\n//     </div>\n//   );\n// }\n"]},"metadata":{},"sourceType":"module"}